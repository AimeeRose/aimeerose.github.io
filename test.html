<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>World Map Test</title>

    <link rel="stylesheet" type="text/css" href="css/colorbrewer.css">
    <style>
      body {
        font-family: sans-serif;
      }
      .background {
        fill: none;
        pointer-events: all;
      }

      .feature {
        fill: #ccc;
        cursor: pointer;
      }

      .feature.active {
        fill: #999;
      }

      .mesh {
        fill: none;
        stroke: #fff;
        stroke-linecap: round;
        stroke-linejoin: round;
      }

      div.label {
        font-family: sans-serif;
      }

      .label h1 {
        margin: 5px 0px;
      }
    </style>

    <script type="text/javascript" src="javascripts/d3.v3.min.js"></script>
    <script type="text/javascript" src="javascripts/topojson.v1.min.js"></script>
    <script type="text/javascript" src="javascripts/colorbrewer.js"></script>
  </head>

  <body>
    <script>
      var greyBlue = "rgb(99,135,166)"
      var lightBlue = "rgb(174,211,242)"
      var yellow = "rgb(255,217,33)"
      var locationTypes = ["micro", "macro", "nano", "brewpub", "production", "office", "tasting", "restaurant", "cidery", "meadery"]
      var width = 960,
          height = 500,
          active = d3.select(null);

      var projection = d3.geo.albersUsa()
          .scale(1000)
          .translate([width / 2, height / 2]);

      var zoom = d3.behavior.zoom()
          .translate([0, 0])
          .scale(1)
          .scaleExtent([1, 8])
          .on("zoom", zoomed);

      var path = d3.geo.path()
          .projection(projection);

      var svg = d3.select("body").append("svg")
          .attr("width", width)
          .attr("height", height)
          .on("click", stopped, true);

      svg.append("rect")
          .attr("class", "background")
          .attr("width", width)
          .attr("height", height)
          .on("click", reset);

      var g = svg.append("g");

      svg
          .call(zoom) // delete this line to disable free zooming
          .call(zoom.event);

      d3.json("data/topojson/us.json", function(error, us) {
        g.selectAll("path")
            .data(topojson.feature(us, us.objects.states).features)
          .enter().append("path")
            .attr("d", path)
            .attr("class", "feature")
            .on("click", clicked);

        g.append("path")
            .datum(topojson.mesh(us, us.objects.states, function(a, b) { return a !== b; }))
            .attr("class", "mesh")
            .attr("d", path);
      });

      function clicked(d) {
        if (active.node() === this) return reset();
        active.classed("active", false);
        active = d3.select(this).classed("active", true);

        var bounds = path.bounds(d),
            dx = bounds[1][0] - bounds[0][0],
            dy = bounds[1][1] - bounds[0][1],
            x = (bounds[0][0] + bounds[1][0]) / 2,
            y = (bounds[0][1] + bounds[1][1]) / 2,
            scale = .9 / Math.max(dx / width, dy / height),
            translate = [width / 2 - scale * x, height / 2 - scale * y];

        svg.transition()
            .duration(750)
            .call(zoom.translate(translate).scale(scale).event);
      }

      function reset() {
        active.classed("active", false);
        active = d3.select(null);

        svg.transition()
            .duration(750)
            .call(zoom.translate([0, 0]).scale(1).event);
      }

      function zoomed() {
        g.style("stroke-width", 1.5 / d3.event.scale + "px");
        g.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
      }

      // If the drag behavior prevents the default click,
      // also stop propagation so we donâ€™t click-to-zoom.
      function stopped() {
        if (d3.event.defaultPrevented) d3.event.stopPropagation();
      }

      var tooltip = function(name, visibility) {
        d3.selectAll(".tooltip").transition().style("opacity", 0).duration(500).style("display", "none").remove();
        
        d3.select("body")
          .append("div")
          .attr("class", "label")
          .attr("class", "tooltip")
          .style("color", "#333")
          .style("z-index", "10")
          .text(name)
          .transition()
          .style("visibility", visibility)
      }

      var projectD = function(d) { return projection([d['locations'][0]['longitude'], d['locations'][0]['latitude']]) }
      var xMap = function(d){if (d['locations'] != null && projectD(d) != null) { return projectD(d)[0]; } else { return null };}
      var yMap = function(d){if (d['locations'] != null && projectD(d) != null) { return projectD(d)[1]; } else { return null };}
      var locationTypeColorScale = d3.scale.ordinal().domain(locationTypes).range(colorbrewer.Spectral[10])

      var addBreweries = function(data) {
        return g.selectAll("circle")
                .data(data)
                .enter()
                .append("circle")
                .attr("cx", xMap)
                .attr("cy", yMap)
                .attr("r", 3)
                .attr("id", function(d) { if (d.locations != null) { return d.name + ', ' + d.locations[0].region }})
                .style("fill", function(d) { if (d.locations != null) { return locationTypeColorScale(d.locations[0].locationType) }})
                .style("stroke", "grey")
                .style("stroke-width", "0.25px")
                .style("opacity", "1")
                .on("mouseover", function(d) { tooltip(d3.select(this).attr("id"), "visibile") })
                .on("mouseout", function(d) { tooltip(d3.select(this).attr("id"), "hidden") });
      }

      var mapBreweries = function(year) {
        if (year <= lastYear) {
          d3.select("body div#year-label").html("<h1>" + year.toString() + "</h1>")
          d3.json("data/breweries/locations/" + year.toString() + "-brewery-locations.json", function(error, breweries) {
            data = breweries.map(function(brewery) {
              if (brewery.locations != null) {
                each_locations = brewery.locations.map(function(loc) {
                  if (loc.country.isoCode == 'US') {
                    single_location = brewery; 
                    single_location.locations = [loc]; 
                  } else { return false }
                  return single_location
                });
              }
              return each_locations;
            })
            var merged_locations = []
            merged_locations = merged_locations.concat.apply(merged_locations, data)
            addBreweries(merged_locations);
          });
          currentYear++
          return setTimeout(function(){ mapBreweries(currentYear) }, 200);
        }
      }

      var years = d3.range(1970, 2014)
      var currentYear = years[0]
      var lastYear = 2014
      d3.select("body").append("div").attr("class", "label").attr("id", "year-label")
        .html("<h1>" + currentYear.toString() + "</h1>")

      var legendRectSize = 18;
      var legendSpacing = 4;
      var legend = svg.selectAll('.legend')
        .data(locationTypeColorScale.domain())
        .enter()
        .append('g')
        .attr('class', 'legend')
        .attr('transform', function(d, i) {
          var height = legendRectSize + legendSpacing;
          var offset =  height * locationTypeColorScale.domain().length / 2;
          var horz = legendRectSize;
          var vert = i * height + legendRectSize;
          return 'translate(' + horz + ',' + vert + ')';
        });
      legend.append('rect')
        .attr('width', legendRectSize)
        .attr('height', legendRectSize)
        .style('fill', locationTypeColorScale)
      legend.append('text')
        .attr('x', legendRectSize + legendSpacing)
        .attr('y', legendRectSize - legendSpacing)
        .style("font-family", "sans-serif")
        .text(function(d) { return d; });

      mapBreweries(currentYear);
    </script>
  </body>
</html>